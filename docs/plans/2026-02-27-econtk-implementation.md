# econtk Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Build a research-grade R package for game theory (non-cooperative + cooperative) with C backends for equilibrium computation.

**Architecture:** R6 classes for game representations, standalone functions for solving/analysis, C code via `.Call()` for performance-critical algorithms. Standard R package layout with `testthat` + `roxygen2`.

**Tech Stack:** R (R6, testthat, roxygen2), C (via .Call), optional GMP for exact arithmetic.

---

## Phase 1: Package Scaffold & Base Classes

### Task 1: Initialize R package structure

**Files:**
- Create: `DESCRIPTION`
- Create: `NAMESPACE`
- Create: `R/econtk-package.R`
- Create: `.Rbuildignore`
- Create: `.gitignore`

**Step 1: Create DESCRIPTION**

```
Package: econtk
Title: Economic Toolkit for Game Theory
Version: 0.1.0
Authors@R: person("Pekka", role = c("aut", "cre"))
Description: Research-grade game theory toolkit for R. Covers non-cooperative
    games (Nash equilibrium computation via Lemke-Howson, support enumeration,
    vertex enumeration), cooperative games (Shapley value, core, nucleolus),
    auction theory, mechanism design, and evolutionary dynamics. Performance-
    critical algorithms implemented in C.
License: MIT + file LICENSE
Encoding: UTF-8
Roxygen: list(markdown = TRUE)
RoxygenNote: 7.3.2
Imports:
    R6
Suggests:
    testthat (>= 3.0.0)
Config/testthat/edition: 3
NeedsCompilation: yes
```

Write to `DESCRIPTION`.

**Step 2: Create NAMESPACE**

```
# Generated by roxygen2: do not edit by hand
export(normal_form)
importFrom(R6, R6Class)
useDynLib(econtk, .registration = TRUE)
```

Write to `NAMESPACE`. (This will be regenerated by roxygen2 later but we need a starting point.)

**Step 3: Create package doc file**

Write `R/econtk-package.R`:

```r
#' @keywords internal
"_PACKAGE"

#' @useDynLib econtk, .registration = TRUE
NULL
```

**Step 4: Create .Rbuildignore**

```
^docs$
^\.git$
^\.gitignore$
^.*\.Rproj$
```

**Step 5: Create .gitignore**

```
.Rproj.user
.Rhistory
.RData
.Ruserdata
src/*.o
src/*.so
src/*.dll
```

**Step 6: Create LICENSE**

Write `LICENSE` with MIT license text.

**Step 7: Create directory structure**

```bash
mkdir -p R src tests/testthat man
```

**Step 8: Create tests/testthat.R**

```r
library(testthat)
library(econtk)

test_check("econtk")
```

**Step 9: Commit**

```bash
git add DESCRIPTION NAMESPACE LICENSE R/ src/ tests/ .Rbuildignore .gitignore
git commit -m "scaffold econtk R package"
```

---

### Task 2: NormalFormGame R6 class

**Files:**
- Create: `R/normal_form_game.R`
- Create: `tests/testthat/test-normal_form_game.R`

**Step 1: Write the failing test**

Write `tests/testthat/test-normal_form_game.R`:

```r
test_that("NormalFormGame stores players and strategies", {
  g <- NormalFormGame$new(
    players = c("Row", "Col"),
    strategies = list(c("U", "D"), c("L", "R")),
    payoffs = array(c(3,1,0,2, 2,0,1,3), dim = c(2, 2, 2))
  )

  expect_equal(g$n_players, 2)
  expect_equal(g$players, c("Row", "Col"))
  expect_equal(g$strategies, list(c("U", "D"), c("L", "R")))
  expect_equal(g$n_strategies, c(2, 2))
})

test_that("NormalFormGame retrieves payoffs correctly", {
  # Prisoner's Dilemma payoffs:
  #          Col: C    Col: D
  # Row: C   (3,3)    (0,5)
  # Row: D   (5,0)    (1,1)
  payoffs <- array(dim = c(2, 2, 2))
  payoffs[1, 1, ] <- c(3, 3)  # (C, C)
  payoffs[1, 2, ] <- c(0, 5)  # (C, D)
  payoffs[2, 1, ] <- c(5, 0)  # (D, C)
  payoffs[2, 2, ] <- c(1, 1)  # (D, D)

  g <- NormalFormGame$new(
    players = c("Row", "Col"),
    strategies = list(c("C", "D"), c("C", "D")),
    payoffs = payoffs
  )

  expect_equal(g$payoff(c(1, 1)), c(3, 3))
  expect_equal(g$payoff(c(1, 2)), c(0, 5))
  expect_equal(g$payoff(c(2, 1)), c(5, 0))
  expect_equal(g$payoff(c(2, 2)), c(1, 1))
})

test_that("NormalFormGame validates inputs", {
  expect_error(
    NormalFormGame$new(
      players = c("Row"),
      strategies = list(c("U", "D"), c("L", "R")),
      payoffs = array(0, dim = c(2, 2, 2))
    ),
    "players.*strategies"
  )
})

test_that("NormalFormGame print method works", {
  payoffs <- array(dim = c(2, 2, 2))
  payoffs[1, 1, ] <- c(3, 3)
  payoffs[1, 2, ] <- c(0, 5)
  payoffs[2, 1, ] <- c(5, 0)
  payoffs[2, 2, ] <- c(1, 1)

  g <- NormalFormGame$new(
    players = c("Row", "Col"),
    strategies = list(c("C", "D"), c("C", "D")),
    payoffs = payoffs
  )

  expect_output(print(g), "Normal Form Game")
})
```

**Step 2: Run test to verify it fails**

```bash
Rscript -e "testthat::test_file('tests/testthat/test-normal_form_game.R')"
```

Expected: FAIL (NormalFormGame not found)

**Step 3: Write NormalFormGame class**

Write `R/normal_form_game.R`:

```r
#' @title Normal Form Game
#'
#' @description R6 class representing a strategic (normal) form game
#' with N players. Payoffs stored as an N+1 dimensional array where the
#' first N dimensions index strategies and the last dimension indexes
#' players.
#'
#' @export
NormalFormGame <- R6::R6Class("NormalFormGame",
  public = list(
    #' @field players Character vector of player names.
    players = NULL,

    #' @field strategies List of character vectors, one per player.
    strategies = NULL,

    #' @field payoff_array N+1 dimensional array of payoffs.
    payoff_array = NULL,

    #' @description Create a new NormalFormGame.
    #' @param players Character vector of player names.
    #' @param strategies List of character vectors of strategy names.
    #' @param payoffs Array of dimension (s1, s2, ..., sN, N) where si is
    #'   the number of strategies for player i.
    initialize = function(players, strategies, payoffs) {
      if (length(players) != length(strategies)) {
        stop("Number of players must match number of strategy sets")
      }
      n <- length(players)
      expected_dim <- c(vapply(strategies, length, integer(1)), n)
      if (!identical(as.integer(dim(payoffs)), as.integer(expected_dim))) {
        stop(
          "Payoff array dimensions must be (",
          paste(expected_dim, collapse = ", "),
          "), got (",
          paste(dim(payoffs), collapse = ", "),
          ")"
        )
      }
      self$players <- players
      self$strategies <- strategies
      self$payoff_array <- payoffs
    },

    #' @description Get number of players.
    #' @return Integer.
    #' @field n_players Number of players (read-only via active binding).

    #' @description Get payoff vector for a strategy profile.
    #' @param profile Integer vector of strategy indices, one per player.
    #' @return Numeric vector of payoffs, one per player.
    payoff = function(profile) {
      idx <- as.list(profile)
      idx[[length(idx) + 1]] <- TRUE  # all players
      do.call(`[`, c(list(self$payoff_array), idx))
    },

    #' @description Print game summary.
    print = function(...) {
      cat("Normal Form Game\n")
      cat("Players:", paste(self$players, collapse = ", "), "\n")
      for (i in seq_along(self$players)) {
        cat(
          " ", self$players[i], ":",
          paste(self$strategies[[i]], collapse = ", "), "\n"
        )
      }
      if (self$n_players == 2) {
        cat("\nPayoff Matrix:\n")
        s1 <- self$strategies[[1]]
        s2 <- self$strategies[[2]]
        header <- paste0("        ", paste(
          formatC(s2, width = 12, flag = "-"), collapse = ""
        ))
        cat(header, "\n")
        for (i in seq_along(s1)) {
          row_str <- formatC(s1[i], width = 8, flag = "-")
          for (j in seq_along(s2)) {
            p <- self$payoff(c(i, j))
            cell <- sprintf("(%s)", paste(round(p, 3), collapse = ","))
            row_str <- paste0(row_str, formatC(cell, width = 12, flag = "-"))
          }
          cat(row_str, "\n")
        }
      }
      invisible(self)
    }
  ),

  active = list(
    #' @field n_players Number of players.
    n_players = function() length(self$players),

    #' @field n_strategies Integer vector of strategy counts per player.
    n_strategies = function() vapply(self$strategies, length, integer(1))
  )
)
```

**Step 4: Run test to verify it passes**

```bash
Rscript -e "testthat::test_file('tests/testthat/test-normal_form_game.R')"
```

Expected: All tests PASS.

**Step 5: Commit**

```bash
git add R/normal_form_game.R tests/testthat/test-normal_form_game.R
git commit -m "add NormalFormGame R6 class with payoff storage and printing"
```

---

### Task 3: normal_form() constructor and classic game factories

**Files:**
- Create: `R/constructors.R`
- Create: `tests/testthat/test-constructors.R`

**Step 1: Write the failing test**

Write `tests/testthat/test-constructors.R`:

```r
test_that("normal_form creates a game from payoff list", {
  # 2-player game: payoffs given as two matrices
  g <- normal_form(
    players = c("Row", "Col"),
    strategies = list(c("U", "D"), c("L", "R")),
    payoffs = list(
      matrix(c(3, 0, 5, 1), nrow = 2, byrow = TRUE),  # Row's payoffs
      matrix(c(3, 5, 0, 1), nrow = 2, byrow = TRUE)    # Col's payoffs
    )
  )

  expect_s3_class(g, "NormalFormGame")
  expect_equal(g$n_players, 2)
  expect_equal(g$payoff(c(1, 1)), c(3, 3))
})

test_that("prisoners_dilemma creates correct game", {
  g <- prisoners_dilemma()

  expect_s3_class(g, "NormalFormGame")
  expect_equal(g$n_players, 2)
  # Mutual defection is (1,1), mutual cooperation is (3,3)
  expect_equal(g$payoff(c(1, 1)), c(3, 3))  # Cooperate, Cooperate
  expect_equal(g$payoff(c(2, 2)), c(1, 1))  # Defect, Defect
  # Temptation > Reward > Punishment > Sucker
  pd_payoffs <- c(
    g$payoff(c(2, 1))[1],  # temptation (5)
    g$payoff(c(1, 1))[1],  # reward (3)
    g$payoff(c(2, 2))[1],  # punishment (1)
    g$payoff(c(1, 2))[1]   # sucker (0)
  )
  expect_true(all(diff(pd_payoffs) < 0))
})

test_that("battle_of_sexes creates correct game", {
  g <- battle_of_sexes()

  expect_s3_class(g, "NormalFormGame")
  # Two pure NE: both at Opera or both at Football
  expect_true(g$payoff(c(1, 1))[1] > 0)  # coordination payoff
  expect_true(g$payoff(c(2, 2))[1] > 0)  # coordination payoff
  expect_equal(g$payoff(c(1, 2)), c(0, 0))  # miscoordination
})

test_that("matching_pennies creates correct zero-sum game", {
  g <- matching_pennies()

  expect_s3_class(g, "NormalFormGame")
  # Zero-sum: payoffs sum to zero for all profiles
  for (i in 1:2) {
    for (j in 1:2) {
      expect_equal(sum(g$payoff(c(i, j))), 0)
    }
  }
})

test_that("coordination_game creates correct game", {
  g <- coordination_game()

  expect_s3_class(g, "NormalFormGame")
  # Diagonal entries are positive, off-diagonal are zero
  expect_true(g$payoff(c(1, 1))[1] > 0)
  expect_true(g$payoff(c(2, 2))[1] > 0)
  expect_equal(g$payoff(c(1, 2)), c(0, 0))
})

test_that("hawk_dove creates correct game", {
  g <- hawk_dove()

  expect_s3_class(g, "NormalFormGame")
  expect_equal(g$n_players, 2)
})
```

**Step 2: Run test to verify it fails**

```bash
Rscript -e "testthat::test_file('tests/testthat/test-constructors.R')"
```

Expected: FAIL (normal_form not found)

**Step 3: Write constructors**

Write `R/constructors.R`:

```r
#' Create a Normal Form Game
#'
#' @param players Character vector of player names.
#' @param strategies List of character vectors of strategy names.
#' @param payoffs List of matrices (one per player) or a single payoff array.
#'   For 2-player games, provide a list of two matrices where each matrix is
#'   n_strategies[1] x n_strategies[2].
#' @return A NormalFormGame object.
#' @export
normal_form <- function(players, strategies, payoffs) {
  n <- length(players)
  dims <- vapply(strategies, length, integer(1))

  if (is.list(payoffs) && !is.array(payoffs)) {
    if (length(payoffs) != n) {
      stop("payoffs list must have one matrix per player")
    }
    arr <- array(dim = c(dims, n))
    for (p in seq_len(n)) {
      if (n == 2) {
        arr[, , p] <- as.matrix(payoffs[[p]])
      } else {
        # N-player: each element should be an array of shape dims
        idx <- rep(list(TRUE), n)
        idx[[n + 1]] <- p
        do.call(`[<-`, c(list(arr), idx, list(as.array(payoffs[[p]]))))
      }
    }
    payoffs <- arr
  }

  NormalFormGame$new(players = players, strategies = strategies, payoffs = payoffs)
}

#' Prisoner's Dilemma
#'
#' @param R Reward for mutual cooperation (default 3).
#' @param T Temptation to defect (default 5).
#' @param S Sucker's payoff (default 0).
#' @param P Punishment for mutual defection (default 1).
#' @return A NormalFormGame object.
#' @export
prisoners_dilemma <- function(R = 3, T = 5, S = 0, P = 1) {
  normal_form(
    players = c("Player 1", "Player 2"),
    strategies = list(c("Cooperate", "Defect"), c("Cooperate", "Defect")),
    payoffs = list(
      matrix(c(R, S, T, P), nrow = 2, byrow = TRUE),
      matrix(c(R, T, S, P), nrow = 2, byrow = TRUE)
    )
  )
}

#' Battle of the Sexes
#'
#' @return A NormalFormGame object.
#' @export
battle_of_sexes <- function() {
  normal_form(
    players = c("Player 1", "Player 2"),
    strategies = list(c("Opera", "Football"), c("Opera", "Football")),
    payoffs = list(
      matrix(c(3, 0, 0, 2), nrow = 2, byrow = TRUE),
      matrix(c(2, 0, 0, 3), nrow = 2, byrow = TRUE)
    )
  )
}

#' Matching Pennies
#'
#' @return A NormalFormGame object (zero-sum).
#' @export
matching_pennies <- function() {
  normal_form(
    players = c("Player 1", "Player 2"),
    strategies = list(c("Heads", "Tails"), c("Heads", "Tails")),
    payoffs = list(
      matrix(c(1, -1, -1, 1), nrow = 2, byrow = TRUE),
      matrix(c(-1, 1, 1, -1), nrow = 2, byrow = TRUE)
    )
  )
}

#' Coordination Game
#'
#' @return A NormalFormGame object.
#' @export
coordination_game <- function() {
  normal_form(
    players = c("Player 1", "Player 2"),
    strategies = list(c("A", "B"), c("A", "B")),
    payoffs = list(
      matrix(c(2, 0, 0, 1), nrow = 2, byrow = TRUE),
      matrix(c(2, 0, 0, 1), nrow = 2, byrow = TRUE)
    )
  )
}

#' Hawk-Dove Game
#'
#' @param V Value of the resource (default 4).
#' @param C Cost of fighting (default 6).
#' @return A NormalFormGame object.
#' @export
hawk_dove <- function(V = 4, C = 6) {
  normal_form(
    players = c("Player 1", "Player 2"),
    strategies = list(c("Hawk", "Dove"), c("Hawk", "Dove")),
    payoffs = list(
      matrix(c((V - C) / 2, V, 0, V / 2), nrow = 2, byrow = TRUE),
      matrix(c((V - C) / 2, 0, V, V / 2), nrow = 2, byrow = TRUE)
    )
  )
}
```

**Step 4: Run test to verify it passes**

```bash
Rscript -e "testthat::test_file('tests/testthat/test-constructors.R')"
```

Expected: All tests PASS.

**Step 5: Commit**

```bash
git add R/constructors.R tests/testthat/test-constructors.R
git commit -m "add normal_form constructor and classic game factories"
```

---

## Phase 2: Equilibrium Solvers (Pure R)

### Task 4: Game property functions

**Files:**
- Create: `R/properties.R`
- Create: `tests/testthat/test-properties.R`

**Step 1: Write the failing test**

Write `tests/testthat/test-properties.R`:

```r
test_that("is_zero_sum detects zero-sum games", {
  expect_true(is_zero_sum(matching_pennies()))
  expect_false(is_zero_sum(prisoners_dilemma()))
})

test_that("is_symmetric detects symmetric games", {
  expect_true(is_symmetric(prisoners_dilemma()))
  expect_true(is_symmetric(matching_pennies()))
  expect_false(is_symmetric(battle_of_sexes()))
})

test_that("dominant_strategy finds dominant strategies", {
  g <- prisoners_dilemma()
  ds <- dominant_strategy(g)
  # Defect is dominant for both players
  expect_equal(ds[[1]], "Defect")
  expect_equal(ds[[2]], "Defect")
})

test_that("dominant_strategy returns NULL when none exists", {
  g <- battle_of_sexes()
  ds <- dominant_strategy(g)
  expect_null(ds[[1]])
  expect_null(ds[[2]])
})

test_that("best_response computes best response to mixed strategy", {
  g <- matching_pennies()
  # Against uniform, both strategies are equally good
  br <- best_response(g, player = 1, opponent_strategy = c(0.5, 0.5))
  expect_equal(length(br), 2)

  # Against pure Heads, best response is Heads (payoff 1 vs -1)
  br <- best_response(g, player = 1, opponent_strategy = c(1, 0))
  expect_equal(br, 1)
})

test_that("is_pareto_optimal identifies Pareto optimal outcomes", {
  g <- prisoners_dilemma()
  # (C,C) = (3,3) is Pareto optimal

  expect_true(is_pareto_optimal(g, c(1, 1)))
  # (D,D) = (1,1) is NOT Pareto optimal (dominated by C,C)
  expect_false(is_pareto_optimal(g, c(2, 2)))
})
```

**Step 2: Run test to verify it fails**

```bash
Rscript -e "testthat::test_file('tests/testthat/test-properties.R')"
```

**Step 3: Write implementation**

Write `R/properties.R`:

```r
#' Check if a game is zero-sum
#'
#' @param game A NormalFormGame object.
#' @return Logical.
#' @export
is_zero_sum <- function(game) {
  stopifnot(inherits(game, "NormalFormGame"))
  if (game$n_players != 2) return(FALSE)
  s1 <- seq_len(game$n_strategies[1])
  s2 <- seq_len(game$n_strategies[2])
  for (i in s1) {
    for (j in s2) {
      if (abs(sum(game$payoff(c(i, j)))) > .Machine$double.eps * 100) {
        return(FALSE)
      }
    }
  }
  TRUE
}

#' Check if a 2-player game is symmetric
#'
#' A 2-player game is symmetric if both players have the same strategy sets
#' and payoffs satisfy: u1(s_i, s_j) = u2(s_j, s_i) for all i, j.
#'
#' @param game A NormalFormGame object.
#' @return Logical.
#' @export
is_symmetric <- function(game) {
  stopifnot(inherits(game, "NormalFormGame"))
  if (game$n_players != 2) return(FALSE)
  if (game$n_strategies[1] != game$n_strategies[2]) return(FALSE)
  n <- game$n_strategies[1]
  for (i in seq_len(n)) {
    for (j in seq_len(n)) {
      p_ij <- game$payoff(c(i, j))
      p_ji <- game$payoff(c(j, i))
      if (abs(p_ij[1] - p_ji[2]) > .Machine$double.eps * 100) return(FALSE)
    }
  }
  TRUE
}

#' Find strictly dominant strategies
#'
#' @param game A NormalFormGame object.
#' @return List with one element per player: the dominant strategy name, or
#'   NULL if no dominant strategy exists.
#' @export
dominant_strategy <- function(game) {
  stopifnot(inherits(game, "NormalFormGame"))
  result <- vector("list", game$n_players)

  for (p in seq_len(game$n_players)) {
    n_s <- game$n_strategies[p]
    if (n_s < 2) {
      result[[p]] <- game$strategies[[p]][1]
      next
    }

    other_players <- setdiff(seq_len(game$n_players), p)
    other_strats <- game$n_strategies[other_players]
    other_profiles <- expand.grid(lapply(other_strats, seq_len))

    dominant <- NULL
    for (s in seq_len(n_s)) {
      is_dominant <- TRUE
      for (s2 in seq_len(n_s)) {
        if (s == s2) next
        for (row in seq_len(nrow(other_profiles))) {
          profile <- integer(game$n_players)
          profile[p] <- s
          profile[other_players] <- as.integer(other_profiles[row, ])
          payoff_s <- game$payoff(profile)[p]

          profile[p] <- s2
          payoff_s2 <- game$payoff(profile)[p]

          if (payoff_s <= payoff_s2) {
            is_dominant <- FALSE
            break
          }
        }
        if (!is_dominant) break
      }
      if (is_dominant) {
        dominant <- game$strategies[[p]][s]
        break
      }
    }
    result[[p]] <- dominant
  }
  result
}

#' Compute best response to an opponent's mixed strategy
#'
#' @param game A 2-player NormalFormGame.
#' @param player Integer (1 or 2).
#' @param opponent_strategy Numeric vector (probability distribution over
#'   opponent's strategies).
#' @return Integer vector of best response strategy indices.
#' @export
best_response <- function(game, player, opponent_strategy) {
  stopifnot(inherits(game, "NormalFormGame"))
  stopifnot(game$n_players == 2)
  stopifnot(player %in% 1:2)
  opp <- 3 - player
  stopifnot(length(opponent_strategy) == game$n_strategies[opp])
  stopifnot(abs(sum(opponent_strategy) - 1) < 1e-10)

  n_s <- game$n_strategies[player]
  expected_payoffs <- numeric(n_s)

  for (s in seq_len(n_s)) {
    for (s_opp in seq_len(game$n_strategies[opp])) {
      profile <- integer(2)
      profile[player] <- s
      profile[opp] <- s_opp
      expected_payoffs[s] <- expected_payoffs[s] +
        opponent_strategy[s_opp] * game$payoff(profile)[player]
    }
  }

  which(abs(expected_payoffs - max(expected_payoffs)) < 1e-10)
}

#' Check if a strategy profile is Pareto optimal
#'
#' @param game A NormalFormGame object.
#' @param profile Integer vector of strategy indices.
#' @return Logical.
#' @export
is_pareto_optimal <- function(game, profile) {
  stopifnot(inherits(game, "NormalFormGame"))
  payoffs_here <- game$payoff(profile)
  all_profiles <- expand.grid(lapply(game$n_strategies, seq_len))

  for (row in seq_len(nrow(all_profiles))) {
    alt <- as.integer(all_profiles[row, ])
    if (identical(alt, as.integer(profile))) next
    alt_payoffs <- game$payoff(alt)
    # Check if alt Pareto dominates profile
    if (all(alt_payoffs >= payoffs_here) && any(alt_payoffs > payoffs_here)) {
      return(FALSE)
    }
  }
  TRUE
}
```

**Step 4: Run tests**

```bash
Rscript -e "testthat::test_file('tests/testthat/test-properties.R')"
```

Expected: All PASS.

**Step 5: Commit**

```bash
git add R/properties.R tests/testthat/test-properties.R
git commit -m "add game property functions: zero-sum, symmetry, dominance, best response, Pareto"
```

---

### Task 5: Pure strategy Nash equilibrium finder

**Files:**
- Create: `R/nash_pure.R`
- Create: `tests/testthat/test-nash_pure.R`

**Step 1: Write the failing test**

Write `tests/testthat/test-nash_pure.R`:

```r
test_that("pure_nash finds PD equilibrium", {
  g <- prisoners_dilemma()
  eq <- pure_nash(g)
  expect_length(eq, 1)
  expect_equal(eq[[1]]$profile, c(2, 2))  # (Defect, Defect)
  expect_equal(eq[[1]]$payoffs, c(1, 1))
})

test_that("pure_nash finds BoS equilibria", {
  g <- battle_of_sexes()
  eq <- pure_nash(g)
  expect_length(eq, 2)
  profiles <- lapply(eq, function(e) e$profile)
  expect_true(list(c(1, 1)) %in% profiles)  # (Opera, Opera)
  expect_true(list(c(2, 2)) %in% profiles)  # (Football, Football)
})

test_that("pure_nash returns empty for matching pennies", {
  g <- matching_pennies()
  eq <- pure_nash(g)
  expect_length(eq, 0)
})

test_that("pure_nash finds coordination equilibria", {
  g <- coordination_game()
  eq <- pure_nash(g)
  expect_length(eq, 2)
})
```

**Step 2: Run test to verify it fails**

```bash
Rscript -e "testthat::test_file('tests/testthat/test-nash_pure.R')"
```

**Step 3: Write implementation**

Write `R/nash_pure.R`:

```r
#' Find all pure strategy Nash equilibria
#'
#' Enumerates all strategy profiles and checks the best response condition
#' for each player.
#'
#' @param game A NormalFormGame object.
#' @return List of equilibria. Each equilibrium is a list with:
#'   \describe{
#'     \item{profile}{Integer vector of strategy indices.}
#'     \item{payoffs}{Numeric vector of payoffs.}
#'     \item{strategy_names}{Character vector of strategy names.}
#'   }
#' @export
pure_nash <- function(game) {
  stopifnot(inherits(game, "NormalFormGame"))
  all_profiles <- expand.grid(lapply(game$n_strategies, seq_len))
  equilibria <- list()

  for (row in seq_len(nrow(all_profiles))) {
    profile <- as.integer(all_profiles[row, ])
    payoffs <- game$payoff(profile)
    is_ne <- TRUE

    for (p in seq_len(game$n_players)) {
      current_payoff <- payoffs[p]
      # Check all deviations for player p
      for (s in seq_len(game$n_strategies[p])) {
        if (s == profile[p]) next
        alt_profile <- profile
        alt_profile[p] <- s
        alt_payoff <- game$payoff(alt_profile)[p]
        if (alt_payoff > current_payoff + .Machine$double.eps * 100) {
          is_ne <- FALSE
          break
        }
      }
      if (!is_ne) break
    }

    if (is_ne) {
      strategy_names <- character(game$n_players)
      for (p in seq_len(game$n_players)) {
        strategy_names[p] <- game$strategies[[p]][profile[p]]
      }
      equilibria[[length(equilibria) + 1]] <- list(
        profile = profile,
        payoffs = payoffs,
        strategy_names = strategy_names
      )
    }
  }
  equilibria
}
```

**Step 4: Run tests**

```bash
Rscript -e "testthat::test_file('tests/testthat/test-nash_pure.R')"
```

**Step 5: Commit**

```bash
git add R/nash_pure.R tests/testthat/test-nash_pure.R
git commit -m "add pure strategy Nash equilibrium finder"
```

---

### Task 6: Support enumeration (mixed strategy NE, R implementation)

**Files:**
- Create: `R/nash_support.R`
- Create: `tests/testthat/test-nash_support.R`

**Step 1: Write the failing test**

Write `tests/testthat/test-nash_support.R`:

```r
test_that("support_enumeration finds matching pennies mixed NE", {
  g <- matching_pennies()
  eq <- support_enumeration(g)
  expect_length(eq, 1)
  # Unique NE is (0.5, 0.5) for both players
  expect_equal(eq[[1]]$strategies[[1]], c(0.5, 0.5), tolerance = 1e-10)
  expect_equal(eq[[1]]$strategies[[2]], c(0.5, 0.5), tolerance = 1e-10)
})

test_that("support_enumeration finds BoS equilibria (pure + mixed)", {
  g <- battle_of_sexes()
  eq <- support_enumeration(g)
  # 3 NE: two pure, one mixed
  expect_length(eq, 3)

  # Check that the two pure NE are there
  pure_profiles <- list()
  mixed_profiles <- list()
  for (e in eq) {
    if (all(e$strategies[[1]] %in% c(0, 1))) {
      pure_profiles[[length(pure_profiles) + 1]] <- e
    } else {
      mixed_profiles[[length(mixed_profiles) + 1]] <- e
    }
  }
  expect_length(pure_profiles, 2)
  expect_length(mixed_profiles, 1)

  # Mixed NE: p1 plays Opera with prob 3/5, p2 plays Opera with prob 2/5
  m <- mixed_profiles[[1]]
  expect_equal(m$strategies[[1]][1], 3 / 5, tolerance = 1e-10)
  expect_equal(m$strategies[[2]][1], 2 / 5, tolerance = 1e-10)
})

test_that("support_enumeration handles PD (single pure NE)", {
  g <- prisoners_dilemma()
  eq <- support_enumeration(g)
  expect_length(eq, 1)
  # (Defect, Defect) = pure strategy = (0,1), (0,1)
  expect_equal(eq[[1]]$strategies[[1]], c(0, 1))
  expect_equal(eq[[1]]$strategies[[2]], c(0, 1))
})
```

**Step 2: Run test to verify it fails**

```bash
Rscript -e "testthat::test_file('tests/testthat/test-nash_support.R')"
```

**Step 3: Write implementation**

Write `R/nash_support.R`:

```r
#' Find all Nash equilibria via support enumeration (2-player)
#'
#' Enumerates all pairs of support sets and solves the indifference
#' conditions. Works for non-degenerate 2-player games. Returns all
#' Nash equilibria found.
#'
#' @param game A 2-player NormalFormGame object.
#' @return List of equilibria. Each equilibrium is a list with:
#'   \describe{
#'     \item{strategies}{List of two numeric vectors (mixed strategies).}
#'     \item{payoffs}{Numeric vector of expected payoffs.}
#'   }
#' @export
support_enumeration <- function(game) {
  stopifnot(inherits(game, "NormalFormGame"))
  stopifnot(game$n_players == 2)

  m <- game$n_strategies[1]
  n <- game$n_strategies[2]

  # Extract payoff matrices
  A <- matrix(0, nrow = m, ncol = n)  # Player 1's payoffs
  B <- matrix(0, nrow = m, ncol = n)  # Player 2's payoffs
  for (i in seq_len(m)) {
    for (j in seq_len(n)) {
      p <- game$payoff(c(i, j))
      A[i, j] <- p[1]
      B[i, j] <- p[2]
    }
  }

  equilibria <- list()

  # Enumerate all non-empty subsets of strategies for each player
  supports_1 <- .all_supports(m)
  supports_2 <- .all_supports(n)

  for (s1 in supports_1) {
    for (s2 in supports_2) {
      result <- .solve_support_pair(A, B, s1, s2, m, n)
      if (!is.null(result)) {
        equilibria[[length(equilibria) + 1]] <- result
      }
    }
  }

  equilibria
}

# Generate all non-empty subsets of {1, ..., n}
.all_supports <- function(n) {
  supports <- list()
  for (k in seq_len(n)) {
    combos <- combn(n, k, simplify = FALSE)
    supports <- c(supports, combos)
  }
  supports
}

# Solve for NE given a pair of support sets
# Returns NULL if no valid NE exists for this support pair
.solve_support_pair <- function(A, B, s1, s2, m, n) {
  k1 <- length(s1)
  k2 <- length(s2)

  # Player 2's mixed strategy q must make player 1 indifferent over s1
  # For all i in s1: sum_j A[i,j]*q[j] = v1 (same value)
  # For all i not in s1: sum_j A[i,j]*q[j] <= v1
  # q[j] = 0 for j not in s2, sum(q[s2]) = 1

  # Player 1's mixed strategy p must make player 2 indifferent over s2
  # For all j in s2: sum_i B[i,j]*p[i] = v2
  # For all j not in s2: sum_i B[i,j]*p[i] <= v2
  # p[i] = 0 for i not in s1, sum(p[s1]) = 1

  # Solve for q (player 2's strategy)
  q_result <- .solve_indifference(A, s1, s2, m, n)
  if (is.null(q_result)) return(NULL)

  # Solve for p (player 1's strategy)
  p_result <- .solve_indifference(t(B), s2, s1, n, m)
  if (is.null(p_result)) return(NULL)

  p <- p_result$strategy
  q <- q_result$strategy
  v1 <- q_result$value
  v2 <- p_result$value

  # Check non-negativity
  if (any(p < -1e-10) || any(q < -1e-10)) return(NULL)
  p <- pmax(p, 0)
  q <- pmax(q, 0)

  # Check that strategies outside support are not profitable
  for (i in seq_len(m)) {
    if (i %in% s1) next
    expected <- sum(A[i, ] * q)
    if (expected > v1 + 1e-10) return(NULL)
  }
  for (j in seq_len(n)) {
    if (j %in% s2) next
    expected <- sum(B[, j] * p)
    if (expected > v2 + 1e-10) return(NULL)
  }

  list(
    strategies = list(p, q),
    payoffs = c(v1, v2)
  )
}

# Solve the indifference system for a support pair
# M is the payoff matrix, s_own is the support of the player being made
# indifferent, s_opp is the support of the mixing player
.solve_indifference <- function(M, s_own, s_opp, n_own, n_opp) {
  k_own <- length(s_own)
  k_opp <- length(s_opp)

  if (k_own > k_opp) return(NULL)

  # System: M[s_own, s_opp] %*% q_sub = v * 1
  # sum(q_sub) = 1
  # Build system: [M_sub, -1; 1...1, 0] [q_sub; v] = [0...0; 1]

  M_sub <- M[s_own, s_opp, drop = FALSE]

  # k_own indifference equations + 1 probability constraint
  # k_opp + 1 unknowns (q_sub + v)
  n_eq <- k_own + 1
  n_var <- k_opp + 1

  if (n_eq != n_var) {
    # Under/over-determined: skip (non-degenerate games have k1 = k2)
    return(NULL)
  }

  lhs <- matrix(0, nrow = n_eq, ncol = n_var)
  rhs <- numeric(n_eq)

  # Indifference: M_sub %*% q_sub - v * 1 = 0
  lhs[1:k_own, 1:k_opp] <- M_sub
  lhs[1:k_own, n_var] <- -1
  rhs[1:k_own] <- 0

  # Probability constraint: sum(q_sub) = 1
  lhs[n_eq, 1:k_opp] <- 1
  lhs[n_eq, n_var] <- 0
  rhs[n_eq] <- 1

  # Solve
  sol <- tryCatch(solve(lhs, rhs), error = function(e) NULL)
  if (is.null(sol)) return(NULL)

  q_sub <- sol[1:k_opp]
  v <- sol[n_var]

  # Build full strategy vector
  q_full <- numeric(n_opp)
  q_full[s_opp] <- q_sub

  list(strategy = q_full, value = v)
}
```

**Step 4: Run tests**

```bash
Rscript -e "testthat::test_file('tests/testthat/test-nash_support.R')"
```

**Step 5: Commit**

```bash
git add R/nash_support.R tests/testthat/test-nash_support.R
git commit -m "add support enumeration for mixed strategy Nash equilibria"
```

---

### Task 7: Unified nash_equilibria() interface

**Files:**
- Create: `R/nash.R`
- Create: `tests/testthat/test-nash.R`

**Step 1: Write the failing test**

Write `tests/testthat/test-nash.R`:

```r
test_that("nash_equilibria auto-selects method for 2-player game", {
  g <- matching_pennies()
  eq <- nash_equilibria(g)
  expect_length(eq, 1)
  expect_equal(eq[[1]]$strategies[[1]], c(0.5, 0.5), tolerance = 1e-10)
})

test_that("nash_equilibria with method='pure' returns only pure NE", {
  g <- battle_of_sexes()
  eq <- nash_equilibria(g, method = "pure")
  expect_length(eq, 2)
  for (e in eq) {
    # All probabilities should be 0 or 1
    for (s in e$strategies) {
      expect_true(all(s %in% c(0, 1)))
    }
  }
})

test_that("nash_equilibria with method='support' works", {
  g <- prisoners_dilemma()
  eq <- nash_equilibria(g, method = "support")
  expect_length(eq, 1)
})

test_that("nash_equilibria prints summary", {
  g <- battle_of_sexes()
  eq <- nash_equilibria(g)
  expect_output(print_equilibria(eq, g), "Nash Equilibri")
})
```

**Step 2: Run test to verify it fails**

```bash
Rscript -e "testthat::test_file('tests/testthat/test-nash.R')"
```

**Step 3: Write implementation**

Write `R/nash.R`:

```r
#' Find Nash equilibria of a game
#'
#' Unified interface that dispatches to the appropriate algorithm based on
#' game type and user preference.
#'
#' @param game A NormalFormGame object.
#' @param method Character: "auto", "pure", "support", "lemke_howson".
#'   Default "auto" selects the best algorithm.
#' @return List of equilibria.
#' @export
nash_equilibria <- function(game, method = "auto") {
  stopifnot(inherits(game, "NormalFormGame"))

  if (method == "auto") {
    if (game$n_players == 2) {
      method <- "support"
    } else {
      method <- "pure"
    }
  }

  switch(method,
    pure = {
      eqs <- pure_nash(game)
      # Convert to mixed strategy format for consistency
      lapply(eqs, function(e) {
        strategies <- vector("list", game$n_players)
        for (p in seq_len(game$n_players)) {
          s <- numeric(game$n_strategies[p])
          s[e$profile[p]] <- 1
          strategies[[p]] <- s
        }
        list(strategies = strategies, payoffs = e$payoffs)
      })
    },
    support = {
      stopifnot(game$n_players == 2)
      support_enumeration(game)
    },
    stop("Unknown method: ", method)
  )
}

#' Print Nash equilibria
#'
#' @param equilibria List of equilibria from nash_equilibria().
#' @param game The NormalFormGame used to compute them.
#' @export
print_equilibria <- function(equilibria, game) {
  n <- length(equilibria)
  cat(sprintf("Nash Equilibria: %d found\n\n", n))

  for (i in seq_along(equilibria)) {
    eq <- equilibria[[i]]
    cat(sprintf("Equilibrium %d:\n", i))
    for (p in seq_len(game$n_players)) {
      strat <- eq$strategies[[p]]
      strat_str <- paste(
        sprintf("%s=%.4f", game$strategies[[p]], strat),
        collapse = ", "
      )
      cat(sprintf("  %s: [%s]\n", game$players[p], strat_str))
    }
    cat(sprintf("  Payoffs: (%s)\n\n",
      paste(round(eq$payoffs, 4), collapse = ", ")
    ))
  }
  invisible(equilibria)
}
```

**Step 4: Run tests**

```bash
Rscript -e "testthat::test_file('tests/testthat/test-nash.R')"
```

**Step 5: Commit**

```bash
git add R/nash.R tests/testthat/test-nash.R
git commit -m "add unified nash_equilibria interface with method dispatch"
```

---

## Phase 3: C Backends

### Task 8: C infrastructure setup

**Files:**
- Create: `src/init.c`
- Create: `src/econtk.h`
- Create: `src/Makevars`

**Step 1: Create C header**

Write `src/econtk.h`:

```c
#ifndef ECONTK_H
#define ECONTK_H

#include <R.h>
#include <Rinternals.h>
#include <R_ext/Rdynload.h>

/* Lemke-Howson algorithm for 2-player bimatrix games */
SEXP c_lemke_howson(SEXP payoff_A, SEXP payoff_B, SEXP n_rows, SEXP n_cols, SEXP init_label);

/* Support enumeration in C */
SEXP c_support_enumeration(SEXP payoff_A, SEXP payoff_B, SEXP n_rows, SEXP n_cols);

#endif
```

**Step 2: Create init.c with routine registration**

Write `src/init.c`:

```c
#include "econtk.h"

static const R_CallMethodDef CallEntries[] = {
    {"c_lemke_howson", (DL_FUNC) &c_lemke_howson, 5},
    {"c_support_enumeration", (DL_FUNC) &c_support_enumeration, 4},
    {NULL, NULL, 0}
};

void R_init_econtk(DllInfo *dll) {
    R_registerRoutines(dll, NULL, CallEntries, NULL, NULL);
    R_useDynamicSymbols(dll, FALSE);
}
```

**Step 3: Create Makevars**

Write `src/Makevars`:

```
PKG_CFLAGS = -std=c99
```

**Step 4: Create stub implementations so package compiles**

Write `src/lemke_howson.c`:

```c
#include "econtk.h"
#include <stdlib.h>
#include <string.h>
#include <math.h>

/*
 * Lemke-Howson algorithm for finding one Nash equilibrium
 * of a 2-player bimatrix game.
 *
 * The algorithm operates on the labeled polytope defined by the
 * best response conditions. It performs complementary pivoting
 * starting from a specified label.
 *
 * Input:
 *   payoff_A: m x n matrix (player 1 payoffs), column-major
 *   payoff_B: m x n matrix (player 2 payoffs), column-major
 *   n_rows: integer, m
 *   n_cols: integer, n
 *   init_label: integer, starting label (1-indexed, 1..m+n)
 *
 * Output:
 *   List with components:
 *     p: numeric vector of length m (player 1 mixed strategy)
 *     q: numeric vector of length n (player 2 mixed strategy)
 *     payoff1: numeric (player 1 expected payoff)
 *     payoff2: numeric (player 2 expected payoff)
 */

/* Pivot operation on a tableau */
static void pivot(double *tableau, int rows, int cols, int piv_row, int piv_col) {
    double piv_val = tableau[piv_row * cols + piv_col];

    /* Scale pivot row */
    for (int j = 0; j < cols; j++) {
        tableau[piv_row * cols + j] /= piv_val;
    }

    /* Eliminate other rows */
    for (int i = 0; i < rows; i++) {
        if (i == piv_row) continue;
        double factor = tableau[i * cols + piv_col];
        for (int j = 0; j < cols; j++) {
            tableau[i * cols + j] -= factor * tableau[piv_row * cols + j];
        }
    }
}

SEXP c_lemke_howson(SEXP payoff_A, SEXP payoff_B, SEXP s_nrows, SEXP s_ncols, SEXP s_init_label) {
    int m = INTEGER(s_nrows)[0];
    int n = INTEGER(s_ncols)[0];
    int init_label = INTEGER(s_init_label)[0] - 1; /* convert to 0-indexed */
    double *A = REAL(payoff_A);
    double *B = REAL(payoff_B);

    int total = m + n;

    /*
     * Set up two tableaux:
     * Tableau 1 (player 1): m rows, (m + n + 1) columns
     *   [I_m | B^T | 1]  (using B transposed because player 2's strategy
     *                      affects player 1's payoff)
     *   Variables: s_1..s_m (slack), q_1..q_n (player 2 probs)
     *
     * Actually, the standard Lemke-Howson formulation:
     *
     * Player 1 polytope P1 (m constraints):
     *   B^T * q + s1 = 1  (s1 >= 0, q >= 0)
     * Labels: s1_i has label i (i = 0..m-1)
     *         q_j has label m+j (j = 0..n-1)
     *
     * Player 2 polytope P2 (n constraints):
     *   A * p + s2 = 1  (s2 >= 0, p >= 0)
     * Labels: s2_j has label m+j (j = 0..n-1)
     *         p_i has label i (i = 0..m-1)
     */

    /* Tableau 1: m rows, (n + m + 1) cols = [s1 vars | q vars | rhs] */
    int t1_rows = m;
    int t1_cols = m + n + 1;
    double *tab1 = (double *)R_alloc(t1_rows * t1_cols, sizeof(double));
    memset(tab1, 0, t1_rows * t1_cols * sizeof(double));

    /* Tableau 2: n rows, (n + m + 1) cols = [p vars | s2 vars | rhs] */
    int t2_rows = n;
    int t2_cols = m + n + 1;
    double *tab2 = (double *)R_alloc(t2_rows * t2_cols, sizeof(double));
    memset(tab2, 0, t2_rows * t2_cols * sizeof(double));

    /* Fill Tableau 1: I_m | B^T | 1 */
    for (int i = 0; i < m; i++) {
        tab1[i * t1_cols + i] = 1.0; /* Identity for slack vars */
        for (int j = 0; j < n; j++) {
            /* B is column-major m x n, B[i,j] = B[j*m + i] in R storage
               B^T[i,j] = B[j,i] = B[i*m + j] ... no:
               B is stored column-major: B[i + j*m]
               We want row i of B^T = column i of B = B[0+i*... no
               B^T[i,j] = B[j,i] = B[j + i*m]
               In column-major: B[j + i*m] = B[j + i*m]
            */
            tab1[i * t1_cols + m + j] = B[i + j * m];
        }
        tab1[i * t1_cols + t1_cols - 1] = 1.0;
    }

    /* Fill Tableau 2: A | I_n | 1 */
    for (int j = 0; j < n; j++) {
        for (int i = 0; i < m; i++) {
            /* A column-major: A[i + j*m] */
            /* In tab2 row j: A^T row j = A col j */
            tab2[j * t2_cols + i] = A[i + j * m];
        }
        tab2[j * t2_cols + m + j] = 1.0; /* Identity for slack vars */
        tab2[j * t2_cols + t2_cols - 1] = 1.0;
    }

    /* Basis tracking: which variable is basic in each row */
    int *basis1 = (int *)R_alloc(m, sizeof(int));
    int *basis2 = (int *)R_alloc(n, sizeof(int));
    for (int i = 0; i < m; i++) basis1[i] = i;         /* s1_0..s1_{m-1} */
    for (int j = 0; j < n; j++) basis2[j] = m + j;     /* s2_0..s2_{n-1} */

    /* Label of each variable:
       Variables 0..m-1 (s1 in tab1, p in tab2): label 0..m-1
       Variables m..m+n-1 (q in tab1, s2 in tab2): label m..m+n-1
    */

    /* Complementary pivoting */
    int entering_label = init_label;
    int max_iters = 2 * (m + n) * (m + n) + 100;

    for (int iter = 0; iter < max_iters; iter++) {
        /* Determine which tableau to pivot in */
        int pivot_in_tab1; /* 1 = tab1, 0 = tab2 */
        int entering_col;

        if (entering_label < m) {
            /* Label 0..m-1: enters as p variable in tab2, column entering_label */
            pivot_in_tab1 = 0;
            entering_col = entering_label;
        } else {
            /* Label m..m+n-1: enters as q variable in tab1, column entering_label */
            pivot_in_tab1 = 1;
            entering_col = entering_label;  /* column index in tableau = entering_label since
                                               cols are [s1(0..m-1) | q(m..m+n-1) | rhs] */
        }

        /* Find pivot row (minimum ratio test) */
        double *tab = pivot_in_tab1 ? tab1 : tab2;
        int tab_rows = pivot_in_tab1 ? t1_rows : t2_rows;
        int tab_cols = pivot_in_tab1 ? t1_cols : t2_cols;
        int *basis = pivot_in_tab1 ? basis1 : basis2;

        int piv_row = -1;
        double min_ratio = 1e300;

        for (int i = 0; i < tab_rows; i++) {
            double coeff = tab[i * tab_cols + entering_col];
            if (coeff > 1e-12) {
                double ratio = tab[i * tab_cols + tab_cols - 1] / coeff;
                if (ratio < min_ratio - 1e-12) {
                    min_ratio = ratio;
                    piv_row = i;
                }
            }
        }

        if (piv_row < 0) {
            /* Unbounded - shouldn't happen for valid games */
            break;
        }

        /* Record leaving variable's label */
        int leaving_var = basis[piv_row];
        int leaving_label = leaving_var; /* variable index = label for this setup */

        /* Perform pivot */
        pivot(tab, tab_rows, tab_cols, piv_row, entering_col);
        basis[piv_row] = entering_col;

        /* Check termination: if we dropped the initial label, we're done */
        if (leaving_label == init_label) {
            break;
        }

        /* Next entering label is the complement of the leaving label */
        entering_label = leaving_label;
    }

    /* Extract solution */
    SEXP result = PROTECT(allocVector(VECSXP, 4));
    SEXP p_vec = PROTECT(allocVector(REALSXP, m));
    SEXP q_vec = PROTECT(allocVector(REALSXP, n));
    SEXP payoff1 = PROTECT(allocVector(REALSXP, 1));
    SEXP payoff2 = PROTECT(allocVector(REALSXP, 1));

    double *p = REAL(p_vec);
    double *q = REAL(q_vec);
    memset(p, 0, m * sizeof(double));
    memset(q, 0, n * sizeof(double));

    /* Read p from tab2 basis: if p_i (variable i, i < m) is basic in row r,
       then p[i] = rhs[r] */
    for (int r = 0; r < n; r++) {
        int var = basis2[r];
        if (var < m) {
            p[var] = tab2[r * t2_cols + t2_cols - 1];
        }
    }

    /* Read q from tab1 basis: if q_j (variable m+j) is basic in row r,
       then q[j] = rhs[r] */
    for (int r = 0; r < m; r++) {
        int var = basis1[r];
        if (var >= m && var < m + n) {
            q[var - m] = tab1[r * t1_cols + t1_cols - 1];
        }
    }

    /* Normalize to probability distributions */
    double p_sum = 0, q_sum = 0;
    for (int i = 0; i < m; i++) p_sum += p[i];
    for (int j = 0; j < n; j++) q_sum += q[j];

    if (p_sum > 1e-15) {
        for (int i = 0; i < m; i++) p[i] /= p_sum;
    }
    if (q_sum > 1e-15) {
        for (int j = 0; j < n; j++) q[j] /= q_sum;
    }

    /* Compute expected payoffs */
    double ep1 = 0, ep2 = 0;
    for (int i = 0; i < m; i++) {
        for (int j = 0; j < n; j++) {
            ep1 += p[i] * q[j] * A[i + j * m];
            ep2 += p[i] * q[j] * B[i + j * m];
        }
    }
    REAL(payoff1)[0] = ep1;
    REAL(payoff2)[0] = ep2;

    SET_VECTOR_ELT(result, 0, p_vec);
    SET_VECTOR_ELT(result, 1, q_vec);
    SET_VECTOR_ELT(result, 2, payoff1);
    SET_VECTOR_ELT(result, 3, payoff2);

    SEXP names = PROTECT(allocVector(STRSXP, 4));
    SET_STRING_ELT(names, 0, mkChar("p"));
    SET_STRING_ELT(names, 1, mkChar("q"));
    SET_STRING_ELT(names, 2, mkChar("payoff1"));
    SET_STRING_ELT(names, 3, mkChar("payoff2"));
    setAttrib(result, R_NamesSymbol, names);

    UNPROTECT(6);
    return result;
}
```

Write `src/support_enum.c` as a stub:

```c
#include "econtk.h"

/* Stub - to be implemented */
SEXP c_support_enumeration(SEXP payoff_A, SEXP payoff_B, SEXP n_rows, SEXP n_cols) {
    return R_NilValue;
}
```

**Step 5: Commit**

```bash
git add src/
git commit -m "add C infrastructure with Lemke-Howson implementation"
```

---

### Task 9: R wrapper for Lemke-Howson and tests

**Files:**
- Create: `R/lemke_howson.R`
- Create: `tests/testthat/test-lemke_howson.R`

**Step 1: Write the failing test**

Write `tests/testthat/test-lemke_howson.R`:

```r
test_that("lemke_howson finds matching pennies NE", {
  g <- matching_pennies()
  eq <- lemke_howson(g)
  expect_equal(eq$strategies[[1]], c(0.5, 0.5), tolerance = 1e-8)
  expect_equal(eq$strategies[[2]], c(0.5, 0.5), tolerance = 1e-8)
})

test_that("lemke_howson finds a BoS equilibrium", {
  g <- battle_of_sexes()
  eq <- lemke_howson(g)
  # Should find one of the three NE
  expect_length(eq$strategies, 2)
  expect_equal(sum(eq$strategies[[1]]), 1, tolerance = 1e-10)
  expect_equal(sum(eq$strategies[[2]]), 1, tolerance = 1e-10)
  expect_true(all(eq$strategies[[1]] >= -1e-10))
  expect_true(all(eq$strategies[[2]] >= -1e-10))
})

test_that("lemke_howson finds PD equilibrium", {
  g <- prisoners_dilemma()
  eq <- lemke_howson(g)
  # (Defect, Defect)
  expect_equal(eq$strategies[[1]][2], 1, tolerance = 1e-10)
  expect_equal(eq$strategies[[2]][2], 1, tolerance = 1e-10)
})

test_that("lemke_howson with different starting labels finds different NE", {
  g <- battle_of_sexes()
  results <- list()
  for (label in 1:4) {
    eq <- lemke_howson(g, init_label = label)
    results[[label]] <- eq
  }
  # At least 2 distinct NE should be found across starting labels
  distinct <- unique(lapply(results, function(e) round(e$strategies[[1]], 6)))
  expect_true(length(distinct) >= 2)
})
```

**Step 2: Run test to verify it fails**

```bash
Rscript -e "testthat::test_file('tests/testthat/test-lemke_howson.R')"
```

**Step 3: Write R wrapper**

Write `R/lemke_howson.R`:

```r
#' Lemke-Howson Algorithm for Nash Equilibrium
#'
#' Finds one Nash equilibrium of a 2-player bimatrix game using the
#' complementary pivoting algorithm of Lemke and Howson (1964).
#' Different starting labels may yield different equilibria.
#'
#' @param game A 2-player NormalFormGame object.
#' @param init_label Integer (1 to m+n): starting label for pivoting.
#'   Default 1.
#' @return List with components:
#'   \describe{
#'     \item{strategies}{List of two numeric vectors (mixed strategies).}
#'     \item{payoffs}{Numeric vector of expected payoffs.}
#'   }
#' @export
lemke_howson <- function(game, init_label = 1L) {
  stopifnot(inherits(game, "NormalFormGame"))
  stopifnot(game$n_players == 2)

  m <- game$n_strategies[1]
  n <- game$n_strategies[2]
  init_label <- as.integer(init_label)
  stopifnot(init_label >= 1L && init_label <= m + n)

  # Extract payoff matrices (column-major for C)
  A <- matrix(0, nrow = m, ncol = n)
  B <- matrix(0, nrow = m, ncol = n)
  for (i in seq_len(m)) {
    for (j in seq_len(n)) {
      p <- game$payoff(c(i, j))
      A[i, j] <- p[1]
      B[i, j] <- p[2]
    }
  }

  result <- .Call(c_lemke_howson, A, B, as.integer(m), as.integer(n), init_label)

  list(
    strategies = list(result$p, result$q),
    payoffs = c(result$payoff1, result$payoff2)
  )
}
```

**Step 4: Build the package and run tests**

```bash
R CMD INSTALL . && Rscript -e "testthat::test_file('tests/testthat/test-lemke_howson.R')"
```

**Step 5: Commit**

```bash
git add R/lemke_howson.R tests/testthat/test-lemke_howson.R
git commit -m "add Lemke-Howson R wrapper with tests"
```

---

## Phase 4: Cooperative Game Theory

### Task 10: CooperativeGame class

**Files:**
- Create: `R/cooperative_game.R`
- Create: `tests/testthat/test-cooperative_game.R`

**Step 1: Write test**

```r
test_that("CooperativeGame stores players and value function", {
  g <- cooperative_game(
    players = c("A", "B", "C"),
    value = function(S) {
      if (length(S) == 0) return(0)
      if (setequal(S, c("A", "B", "C"))) return(10)
      if (setequal(S, c("A", "B"))) return(7)
      if (setequal(S, c("A", "C"))) return(5)
      if (setequal(S, c("B", "C"))) return(4)
      if ("A" %in% S) return(3)
      if ("B" %in% S) return(2)
      if ("C" %in% S) return(1)
      0
    }
  )

  expect_equal(g$n_players, 3)
  expect_equal(g$value(c("A", "B", "C")), 10)
  expect_equal(g$value(character(0)), 0)
})
```

**Step 2-3: Implement CooperativeGame R6 class and cooperative_game() constructor.**

The class stores:
- `players`: character vector
- `value_fn`: the characteristic function v(S)
- `value(S)`: method that calls value_fn
- `is_superadditive()`: check superadditivity
- `is_convex()`: check convexity

**Step 4: Run tests, Step 5: Commit.**

---

### Task 11: Shapley value

**Files:**
- Create: `R/shapley.R`
- Create: `tests/testthat/test-shapley.R`

**Implementation:** Compute Shapley value using the permutation formula:

phi_i = (1/n!) * sum over permutations R of [v(S_i^R union {i}) - v(S_i^R)]

where S_i^R is the set of players preceding i in permutation R.

For small n (<=10), exact computation. For larger n, Monte Carlo sampling.

**Tests:** Use the classic glove game (known Shapley values) and the airport game.

---

### Task 12: Core and nucleolus

**Files:**
- Create: `R/core.R`
- Create: `tests/testthat/test-core.R`

**Implementation:**
- `core_vertices(game)`: enumerate vertices of the core polytope (LP-based)
- `in_core(game, allocation)`: check if an allocation is in the core
- `nucleolus(game)`: compute the nucleolus via iterated LP

---

## Phase 5: Extensive Form Games

### Task 13: ExtensiveFormGame class with tree builder

Builder pattern with `add_node()`, `add_terminal()`, `add_info_set()`.

### Task 14: Backward induction solver

Subgame perfect equilibrium via backward induction for perfect information games.

---

## Phase 6: N-Player Games

### Task 15: N-player normal form support

Generalize `NormalFormGame` payoff handling and `pure_nash` for N > 2.

### Task 16: Homotopy continuation (C)

Implement simplicial subdivision or homotopy for computing NE in N-player games.

---

## Phase 7: Auction Theory

### Task 17: Auction game constructors and equilibrium computation

- `first_price_auction(n, values)` / `second_price_auction(n, values)`
- `english_auction()` / `dutch_auction()`
- Revenue equivalence theorem verification
- Optimal bidding functions for standard distributions

---

## Phase 8: Mechanism Design

### Task 18: VCG mechanism and incentive compatibility

- `vcg_mechanism(valuations, allocation_rule)`
- `is_incentive_compatible(mechanism)`
- `is_individually_rational(mechanism)`

---

## Phase 9: Evolutionary Dynamics

### Task 19: Replicator dynamics and learning algorithms

- `replicator_dynamics(game, x0, t_max)`
- `fictitious_play(game, n_rounds)`
- `best_response_dynamics(game, x0, n_rounds)`

---

## Phase 10: Package Polish

### Task 20: NAMESPACE, roxygen2, vignettes, R CMD check

- Generate proper NAMESPACE via roxygen2
- Write "Getting Started" vignette
- Run `R CMD check --as-cran`
- Fix all warnings and notes
